//query_regions.h taking place of config.h generated by ./configure
#include "query_regions.h"

//declaration of args_t in tabix.c 
typedef struct
{
    char *regions_fname, *targets_fname;
    int print_header, header_only, cache_megs, download_index, separate_regs;
}
args_t;





    /**********************
     * OPENING INPUT FILE *
     **********************/


/**
 * Open an HTSlib File
 *
 *
 * @param fn   The file name of the HTSlib file to be opened.
 * @param mode The mode in which to open the file (in our case, always "r" for reading).
 * @param fmt  TO COMPLETE
 * @return     A pointer to the opened `htsFile`, or NULL if an error occurs.
 */

htsFile *hts_opening(const char *fn, const char *mode)
{
    char smode[101], *cp, *cp2, *uncomp = NULL;
    htsFile *fp = NULL;
    hFILE *hfile = NULL;
    char fmt_code = '\0';


    strncpy(smode, mode, 99);
    smode[99]=0;
    if ((cp = strchr(smode, ',')))//== 0, so false
        *cp = '\0';

    // Migrate format code (b or c) to the end of the smode buffer.
    for (cp2 = cp = smode; *cp; cp++) // initialise cp2 = 0
    {
        if (*cp == 'b')
            fmt_code = 'b';
        else if (*cp == 'c')
            fmt_code = 'c';
        else {//will enter here, puts cp2 back to 0
            *cp2++ = *cp;
            // Cache the uncompress flag 'u' pos if present
            if (!uncomp && (*cp == 'u')) {
                uncomp = cp2 - 1;
            }
        }
    }
    *cp2++ = fmt_code;
    *cp2++ = 0;


    hfile = hopen(fn, smode);
    if (hfile == NULL) goto error;

    fp = hts_hopen(hfile, fn, smode);
    if (fp == NULL) goto error;

    return fp;

error:
    fprintf(stderr, "Failed to open the file");

    if (hfile)
        hclose_abruptly(hfile);

    return NULL;
}


    /****************************************
     * ITERATING & PRINTING SPECIFIED RANGE *
     ***************************************/

/**
 * Open and reads from a file
 *
 * This function allows you to open the input file (always in vcf format)
 * with a call to hts_opening, before reading within a specified range 
 * and displaying it to stdout 
 *
 * @param args   A pointer to the arguments structure containing query parameters.
 * @param conf   A pointer to the struct defining region indexing (contains a conf struct).
 * @param fname  The name of the input file.
 * @param regs   An array of region strings to be queried (in the future, multiple ?).
 * @param nregs  The number of regions in the `regs` array (for now 1).
 * 
 * @return       An integer status code (0 for success, 1 for failure).
 */

//is puts() the best course of action ? 

static int query_regions_and_list_chroms(args_t *args, tbx_conf_t *conf, char *fname, char **regs, int nregs, int list_chroms)
{
    htsFile *fp = hts_opening(fname,"r");//Null goes to htsFormat, maybe hardcodable
    if ( !fp ) 
    {
        fprintf(stderr, "Failed to open the file");
        return 1;
    }
    
    enum htsExactFormat format = (&fp->format)->format; // will always be vcf but to be sure
    if ((format != vcf)) 
    {
        fprintf(stderr, "\"%s\" is not a supported format, try a vcf file", fname);
        return 1; // exit(EXIT_FAILURE);
    }

    if (!regs || !(*regs))
    {
        fprintf(stderr, "No region specified, please enter a region like so : Chrom_id:First_Index-Last_Index \n");
        //find a way to print whole file if no region specified ? 
        return 1; //exit(EXIT_FAILURE); alternatively
    }

    if (args->cache_megs)//hardcode for the time being (10), will possibly be updated
    {
        //remove unecessary function hts_set_cache_size
        if (fp->format.compression == bgzf)
            bgzf_set_cache_size(hts_get_bgzfp(fp), args->cache_megs * 1048576);
    }


    regidx_t *reg_idx = NULL; //will stay that way until regidx_overlap call

    tbx_t *tbx = tbx_index_load3(fname, NULL, args->download_index ? HTS_IDX_SAVE_REMOTE : 0);//TODO : check to simplify

        if ( !tbx )
        {
            fprintf(stderr, "Could not load .tbi/.csi index of %s \n", fname);
            return 1; //exit(EXIT_FAILURE);
        }
        kstring_t str = {0,0,0};

        const char **seq = NULL;


        //LISTING ONLY CHROMOSOMES IF "list_chroms" != 0

        int i;
        if (list_chroms)
        {
            int i, nseq = 0;
            seq = tbx_seqnames(tbx, &nseq); //very weird func who gives nbr of chroms to nseq and array of chroms to seq
            if (!seq)
                fprintf(stderr, "Couldn't get list of sequence names");
            for (i=0; i<nseq; i++)
            {
                if (printf("%s\n", seq[i]) < 0)
                    fprintf(stderr, "Failed to write to stdout");
            }
            free(seq);
            tbx_destroy(tbx);
            return 0;//be sure not to print region or not to cause Segfault
        }


        for (i=0; i<nregs; i++)
        {
            int ret, found = 0;
            hts_itr_t *itr = tbx_itr_querys(tbx, regs[i]);
            if ( !itr ) continue;
            while ((ret = tbx_itr_next(fp, tbx, itr, &str)) >= 0)
            {
                //overkill i we only treat one region
                if ( reg_idx && !regidx_overlap(reg_idx,seq[itr->curr_tid],itr->curr_beg,itr->curr_end-1, NULL) ) continue;
                if (!found) {
                    if (args->separate_regs) printf("%c%s\n", conf->meta_char, regs[i]);
                    found = 1;
                }
                if (puts(str.s) < 0)
                    fprintf(stderr, "Failed to write to stdout");
            }
            if (ret < -1) fprintf(stderr, "Reading \"%s\" failed", fname);
            tbx_itr_destroy(itr);
        }
    free(seq);
    free(str.s);
    tbx_destroy(tbx);
    return 0;
}


/**
 * Hardcode the good arguments to query_regions
 *

 * @param fn   The file name or input data source.
 * @param region The range.
 */

//integrable dans query_regions directement ?
int generate_query_arguments(char *fname, char **regions, int nregs_hardcode, int list_chroms)
{
    args_t *args_hardcode;//rm malloc, will Segfault, need to add it later on
    args_hardcode->regions_fname = 0x0;
    args_hardcode->targets_fname = 0x0;
    args_hardcode->print_header = 0;
    args_hardcode->header_only = 0;
    args_hardcode->cache_megs = 10; 
    args_hardcode->download_index = 1;
    args_hardcode->separate_regs = 0;
    tbx_conf_t conf_hardcode_instance = { 2, 1, 2, 0, 35, 0 };
    tbx_conf_t *conf_hardcode = &conf_hardcode_instance;
    return query_regions_and_list_chroms(args_hardcode, conf_hardcode, fname, regions, nregs_hardcode, list_chroms);
}

//remove the main

int interface(const char *entry)
{ 
  int l_flag = 0;
  char ** regions = NULL;
  int nregs = 0;
  char * filename = strdup(entry);
  // check old main to get what's going on
  // for char **regions, which stores the region in an array of string (one element = one region)
  return generate_query_arguments(filename, regions, nregs, l_flag);
}